An Introduction to Computer Science and Programming with Python
===============================================================
Ed Harcourt <edharcourt@stlawu.edu>
v0.1, May 2017:
:toc: right
:numbered:
:icons: font
:source-highlighter: pygments
:stem: latexmath
:imagesdir: ./images
:includedir: .
:docinfo:

[preface]
== Preface

I have been teaching the Introduction to Computer Programming course at St. Lawrence University since 2003. The course at St. Lawrence is the first course in the Computer Science major sequence it is also designed to satisfy a general education requirement called _quantitaive and logical reasoning_. As such, it assumes no prior programming  experience, and students from across campus in a variety of disciplines take this course. It is also 

Goals of the course include:

* Appreciate the complexity of the software systems we encounter every day
* Emphasize problem soving in a precise, logical framework 
* Explore a multitude of topics in computer science such as; image processing, simulation and randomness, cryptography, network communications, and much more.

== Introduction

_Computer Science_ is the field of study encompassing the theory and practical implementation of processing digital information. It includes such diverse areas networking, cryptography, security, web development, artificial intelligence, databases, computer graphics, mobile computing ... another list that could continue for some time. What this has enabled is astonishing; self driving cars, social media, voice and image recognition, digital music and video streaming (_e.g.,_ Spotify and Netflix), online shopping and banking, digital maps and GPS. Biologists use software to analyze DNA, Doctors use software to understand how genes impact disease.  Pharmacolgists search for new drugs using software. Computer programming and software is the thread that knits all of these together. It is where any introduction to computer science begins.

A _computer program_ (_i.e.,_ software) is developed and written in a _programming language_. There are, literally, thousands of programming languages, mostly dead now, https://en.wikipedia.org/wiki/List_of_programming_languages[but there are many hundreds still in active use].footnote:[Back in my college days some of the languages I learned were COBOL, Ada, Pascal, Prolog, SNOBOL, Lisp, Fortran, and APL. Most of these are dead in their original form. Lisp and Fortran have both lived on in some evolved form and have also had a profound impact on the design of many other languages languages still used today.] About a dozen languages dominate the modern software development landscape, and many more are actively used in niche areas such as engineering and the visual arts.  

The https://developer.mozilla.org/en-US/docs/Web/JavaScript[Javascript programming language] (not to be confused with the https://www.oracle.com/java/index.html[Java programming language]) is part of every web browser and just about every web site makes use of Javascript in some way. Most computer games are written in https://en.wikipedia.org/wiki/The_C_Programming_Language[C] or https://en.wikipedia.org/wiki/C%2B%2B[C++]. Native iPhone apps are written in https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Introduction/Introduction.html[Objective-C] or https://developer.apple.com/swift/[Swift], while native Android apps use  https://developer.android.com/studio/index.html[Google's version of Java]. Statisticians and data scientists frequently use https://www.r-project.org/[R]. Scientists and engineers are partial towards https://www.mathworks.com/[MATLAB] or https://www.wolfram.com/mathematica/[Mathematica]. https://processing.org/[Processing] is a special purpose language for the visual arts. https://en.wikipedia.org/wiki/Verilog[Verilog] and https://en.wikipedia.org/wiki/VHDL[VHDL] are well established languages for designing electronic circuits. This list could go on. The https://www.tiobe.com/tiobe-index/[TIOBE Index] attempts to measure programming language popularity.

NOTE: A _programming language_ is precise notation used for describing computations to be carried out by a computing device (_e.g.,_ a computer, smartphone, tablet, etc.). Like a natural language such as English or German, a programming language has an alphabet, words, grammar (syntax), and meaning (semantics).

=== Software is taking over 
Almost every aspect of our daily life is impacted by software. Think about each of the following and what has changed and if there is software behind that change.

* How often do you go into a bank and interact with a teller? What do you use instead?

* What has happened to book stores, from your local book store to large chain stores such as Barnes and Noble and Borders? 

* When was the last time you used a travel agent to purchase an airline ticket?

* What has happened to DVD stores such as Blockbuster?

* What is disrupting the hotel and taxi industry?

* What has happened to music stores where we used to purchase albums and CDs?

* When was the last time you took a roll of film to get developed?

* When was the last time you wrote a letter and mailed using the post office?

* Your smart phone is a powerful computing device, how often do you look at in a day, and what do you use it for?

* Thinking further in to the future what could happen to the millions of people who drive for a living, from taxi drivers to truck drivers? 

=== Hello World

https://www.python.org/[Python] is a popular programming language used widely in industry. It is also used in introductory courses because it is relatively easy to use and get started with.  So lets get started.

It is almost obligatory that https://en.wikipedia.org/wiki/%22Hello,_World!%22_program[Hello World] be the first program one writes in any programming language. Here is our first python program:

[source,python]
print("Hello world")

////
.This will have a link next to it
----
* always displayed
* always displayed 2
----

[.result]
====
* hidden till clicked
* hidden till clicked 2
====
////

That is it, just the one line. And it does as you might expect, it prints the message `Hello World` on the console. But there is a lot going on in that one line, so lets break it down. 

The python _builtin function_ `print` prints, to the console, the value between the parentheses. In this case the value being printed is the _string literal_ `"Hello World"`.  A string literal in python is a sequence of characters between double quotes or single quotes. More on string literals later.

NOTE: In programming, a string literal is also called _string constant_

The `print` function can take multiple values separated by commas.

[source,python]
print("The value of pi squared is", 3.14159 * 3.14159)

produces the output 

[source]
The value of pi squared is 9.869587728099999

And we can see right here that `*` is a character in the alphabet, that two values are on both sides of the `*` (syntax), and that `*` must mean _multiplication_ (semantics).

NOTE: In mathematics a _function_ maps values in a _domain_ to values in a _range_. For example, the function stem:[f(x) = x^2] maps the input 2 to the output 4, 3 to 9,  1.5 to 2.25, etc. 

Pictorially we often think of a function as a black box (we don't know how it works) where values come in (represented by the arrow coming in on the left) and the function produces values (the return results represented by the arrow coming out of the box on the right).  

image::function-fx.png[align="center"]

Values that are passed to a function are called _arguments_. The second argument in the call to the `print` function above is the mathematical expression `3.14159 * 3.14159`. In just about every programming lananguage the asterisk character `*` represents multiplication. A value such as `3.14159` in mathematics is called a _real number_ (a number with a decimal point). For reasons I wont go into now in computer science and programming we call them _floating-point_ numbers, or _floats_ for short.

There is a big difference between the string literal `"3.0`" and the floating-point literal `3.0`. To see this, what would get printed by the following print statement?

[source,python]
print("3.0 * 3.0", 3.0 * 3.0)

Numbers without decimal points are called _integers_ or _ints_ for short. 

=== Integer and floating-point literals

Valid _integer literals_ include numbers such as 0, 1, 2, ... and also negative integers -1, -2, ...

IMPORTANT: don't start integer literals with a leading 0, such as 09. This is an error in Python.

Floating-point literals include a decimal place, and include numbers such as 0.3, -0.3, .3, 3., -3.14159. 

Python (as do most programming languages) supports specifying numbers using _scientific notation_. For example, in Chemistry and Physics, Avagadro's number is stem:[6.022140857 \times 10^{23}]. Writing this out as `602214085700000000000000` is not very readable. In Python we can instead write `6.022140857e23`.

We can also use scientific notation for very small numbers.  The mass of an electron is stem:[9.10938356 \times 10^{-31}] kg.  Again, writing this as `0.000000000000000000000000000000910938356` is silly. We can simply say `9.10938356e-31`.

TIP: An integer (floating-point) literal is also called an _integer (floating-point) constant_.

.Example +++<span style='color:red;margin-right:1.25em; display:inline-block;'>&nbsp;&nbsp;&nbsp;</span>+++
The radius of an electron is 0.00000000000000281792 meters. Express this number using Python's scientific notation.

[.result]
====
`2.81792e-15`  # meters
====

=== Variables

Let's return to our simple program ...

[source,python]
print("The value of pi squared is", 3.14159 * 3.14159)

It would be nice to give the value `3.14159` a name. An obvious choice being `pi`.  We do that in Python using an _assignment statement_.

[source,python]
pi = 3.14159

And we can rewrite our program as 

[source,python]
pi = 3.14159
print("The value of pi squared is", pi * pi)

To the left of the `=` sign is a _variable name_ and we read the assignment statement above as `pi` _gets the value of_ the value on the right of `=`, in this case `3.14159`.

Variable names in Python are should be meaningful, they must start with either an alphabetic character (a - z, A - Z) or underscore, and may also contain digits. Variable names are also _case sensitive_, so `pi`, `Pi`, and `PI` are all different variable names.

The value of on the of `=` can also be an _expression_.

IMPORTANT: Students often confuse `=` with mathematical equality and think `3.14159 = pi` is the same thing as `pi = 3.14159`. This former is not valid Python.

[source,python]
pi = 3.14159
pi_squared = pi * pi
print("The value of pi squared is", pi_squared)

IMPORTANT: Variables must be defined before they are used.

The Python program 

[source,python]
print(x)

would produce an error becuse the variable `x` does not have a value.

IMPORTANT: Variable names are not string literals.

.There is a big difference between the two statements...
[source,python]
----
print("The value of pi squared is", pi_squared) # <1>
print("The value of pi squared is", "pi_squared") # <2>
----

[.result]
<1> prints `The value of pi squared is 9.869587728099999`
<2> prints `The value of pi squared is pi_squared` +
Almost certainly not what was intended.

=== Comments

We can add notes to our program using a _comment_. In Python a one line comment starts 
with a hashtag and continue to the end of the line.

[source,python]
----
# define a variable pi
pi = 3.14159
----

You can also use a comment to finish a line.

[source,python]
----
pi = 3.14159   # define a variable pi
----

=== Mathematical Expressions

The arithmetic operators we will be using most are:

[cols="1,8", width="50%", options="header"]
.Mathematical Operators
|===
|Operator | operation
|`+`
|addition
|`-`
|subtraction
|`*`
|multiplication
|`/`
|floating-point division
|`//`
|integer division
|`%`
|remainder (modulus)
|`**`
|exponentiation
|===

Python has many more operators, but this is all we will need for now.  You can combine these operations in complicated ways including using parentheses. The _normal 
order of operations_ you learned in grade school apply.

. parentheses
. exponention
. multiplication, division (include remainder)
. addition and subtraction

==== Examples

What is the output of each of the examples below?

.Example 1
[source,python]
----
x = 3 + 5 * 9
print(x)
----

[.result]
====
`48`
====

.Example 2
[source,python]
----
x = 1/2 <1>
print(x)
----

[.result]
====
`0.5`
====
<1> Recall that the single slash `/` is _floating-point division_, meaning the result is 
a floating-point number.

Contrast this with _integer division_ using the double slash operator `//`. 
In integer division the result is always an integer.

.Example 3
[source,python]
----
w = 1 // 2
x = 3 // 7
y = 3 // 2
z = 77 // 5
print(w,x,y,z)
----

[.result]
====
`0 0 1 15`
====
 
Integer division will plays a key role in many applications incomputer science.

.Example 4
[source,python]
----
x = 7
y = 9
z = x + y // 4 * x - 2 ** 3
print(z)
----

[.result]
====
`13`
====

Expressions produce a value. Something must be done with that value such as assign it to a variable or use it as an argument in a function call (such as `print`).  Consider the following Python program.

[source,python]
----
two_pi = 3.14159 * 2 <1>
two_pi * two_pi <2>  
print(two_pi) <3>
----
<1> compute 2&pi; and store the result in the variable `two_pi`
<2> multiply `two_pi` times `two_pi` _and do nothing with the result_ so Python just throws the value away. *This line is pointless*, it has no effect, but it is legal.
<3> print `two_pi`

=== Modular Arithmetic

_Modular arithmetic_ is important in computer science.  Modular arithmetic is just arithmetic that uses the remainder after finding a quotient. For example, `7 // 3` is `2` with a remainder of `1`. The remainder operator is `%`. In this case `7 % 3` is `1`.

.Check Yourself
[source,python]
----
# What gets printed by the following?
w = 1 % 2
x = 3 % 7
y = 3 % 2
z = 77 % 5
print(w,x,y,z)
----

[.result]
====
`1 3 1 2`
====

A couple of important properties to remember. If we are computing `n % m` and we know that `n` is less than `m` and they are both positive, then the result is always `n`. For example `278 % 455` is `278`.

TIP: In mathematics we sometimes refer to modular arithmetic as _clock arithmetic_. You perform modular arithmetic all the time, you just don't know it. For example, if it is 2PM and we wanted to figure out what time it will be 14 hours from now, we can compute `(2 + 14) % 12`, which is 4. So it would be 4AM.  

Computing the modulus of a negative number is also important, for example `-1 % 12`. Think of computing the modulus of a negative number as going _counter clockwise_ around the clock. For example, `-1 % 12` is `11`, and `-5 % 12` is `7`.  

`-14 % 12` would be to go counter clockwise one full revolution leaving s with `-2 % 12`, which is `10`. 

.Check Yourself
[source,python]
----
# What gets printed by the following?
w = -1 % 2
x = -3 % 7
y = -3 % 2
z = -77 % 5
print(w,x,y,z)
----

[.result]
====
`1 4 1 3`
====

TIP: We will see a use of computing the modulus of a negative number in cryptography.

=== More on String Literals

Strings are an important part of programming. Strings often seem boring but they are partof every piece of software and are often central to applications such web searching, texting, email, DNA sequence analysis, and cryptography.

A string literal is a sequence of characters between double quotes. 

[source,python]
"This is a valid string literal"

Or single quotes.

[source,python]
'and so is this'

IMPORTANT: the opening and closing quotes in a string literal must match

[source,python]
"but this string literal has an error, why?'

[source,python]
'and so does this, why?"

But what if we want to include a single quote as one of the characters in our string literal? One way to do it is to use double quotes for the string literal.

[source,python]
"This isn't an error"

This works becuase the outer double quotes demarcate the string literal and the single quote in `don't` is just a single quote character because it is inside the double quotes.

The following is incorrect.

[source]
'It isn't easy to see that this is an error, why?'

Python can't tell that the second single quote in `isn't` is part of the word but recognizes it as the closing quote matching the open quote.

.What would get printed by the following print statement?
[source,python]
----
print('He said "Do it!"') 
----

[.result]
====
`He said "Do it!"`
====

Things can get pretty crazy. How about if we wanted to print the string _He said "Don't do it!"_.  The issue here is that the string we are printing contains a mix of double and single quotes. The trick is that we need to _escape_ one of the quote characters. For example, if we need a single quote to be the single quote character and not the start or end of a string literal we can put a backslash character in front of it. 

The statement

[source,python]
print('He said "don\'t"') 

produces the output 

[source]
He said "don't"


=== A note about spaces

Spaces, like in writing, are used to separate words in Python, and are often used to make code more readable. For example, in a `print` statement you can put a space after the comma that is separating values to print.

[source,python]
print(a, b, c, d) 

which might look slightly less cramped than
 
[source,python]
print(a,b,c,d) 

Spaces can also make code less readable,

[source,python]
print(a      ,           b,c,                       d) 

is also valid -- but ugly.

WARNING: Spacing at the start of a line that changes indentation can cause problems. See the next section.

=== A note about indentation

We will see later on that indentation plays an important role in Python. For now you should just note that all python statements that are _at the same level_ (and we wont really know what that means until we get to more complicated Python) should be indented exactly the same. 

Here is an example. The following program is in error because the second statement is indented one space.

[source,python]
x = 4
 print(x*x)

TIP: Python is unique in the way that it treats indentation. Most other programming languages are not sensitive to the way that indentation is handled.

=== Syntax Errors

We've already encountered ways in which we can violate the rules of the language. In computer programming we call these _syntax errors_. 

NOTE: A _syntax error_ is an error that violates the rules of the language. Syntax errors
can be detected _before_ the program executes. 

Find the error in each of the following:

.Example 1
----
print("Hello)
----

[.result]
====
Missing double quote closing the string lteral `"Hello"`.
====

.Example 2
----
print("Hello')
----

[.result]
====
Mismatched quotes.
====

.Example 3
----
print("Hello"
----

[.result]
====
Missing closing parentheses.
====

.Example 4
----
print("Hello" 77)
----

[.result]
====
Missing comma between `Hello` and `77`.
====

.Example 5
----
print(x)
----

[.result]
====
Variable `x` is not defined.
====

.Example 6
----
 x = 5
print(x)
----

[.result]
====
Indentation error
====

.Example 7
----
x = 5 9
print(x)
----

[.result]
====
Python expects there to be something _between_ the `5` and the `9` such as a mathematical operator `+` or `*`.
====

.Example 8
----
5 = x
print(x)
----

[.result]
====
Python expects there to be something a variable to the left of `=`.
====

.Example 9
----
x = 8 @ 7
print(x)
----

[.result]
====
Python does not have an operator named `@`.
====

Some syntax errors are just nasty and difficult to find. The following one line program looks like it should be a syntax error non-sensical but shows a common mistake of leaving off the parentheses when calling a function. But the program actually runs.

.Example 8
----
print
----

[.result]
====
<built-in function print>
====

As you gain practice you will be able to quickly find syntax errors.

=== Keyboard Input

Python's `input` function allows the user to enter input from the keyboard. It takes a string as an argument and uses it as a prompt. The `input` function is a different kind of function than the `print` function. The `print` puts values on the Python console window whereas the `input` function produces a string value of the characters that the user typed.

[source,python]
name = input('Enter your name: ')
print("Hello", name)

 Enter your name: Hermione <1>
 Hello Hermione
 
<1> `Hermione` is what the user typed and then hit _enter_ on the keyboard.
 
It is common to have users enter numbers and then use the values in mathematical expressions. The formula to convert a temperature in fahrenheit to celsius is 
latexmath:[5/9(f-32)]

[source,python]
f = input('Enter a temperature (F): ')
c = 5/9*(f - 32)
print(f, "fahrenheit is", c, "celsius")

Unfortunately `f` contains a string, not a number, and `(f - 32)` has an error because you can't subtract 32 from a string. You need to first convert `f` to either 
an integer or a floating-point number using either the `int` or `float` function.

WARNING: The `input` function returns a string value, even if the user entered a number. You must convert the string to a number using the `int` or `float` function if you intend to use the input in a mathematical expression.

.The `int` function

The function `int` takes a string argument and attempts to convert it to an integer and return the resulting integer. For example `int("-36")` would return the integer `-36`. The `int` function is also used to convert a floating-point number to an integer by truncating the decimal point. For example `int(3.14159)` would return `3`. Sometimes `int` can result in a _run-time error_. For example `int("3.14159")` causes an error because the string cannot converted to an integer. What about `int('hello')`?

NOTE: A _run time error_ is an error that can only be detected when the program executes and not before. A run-time error is often called a _crash_. You'll often hear programmers say "The programming is crashing" or "the program crashes on this line of code".

.The `float` function
NOTE: The function `float` takes a string argument and attempts to convert it to a floating-point number and return the resulting float. For example `int("-3.14")` would return the float `-3.14`. The `float` function is also used to convert an integer to a float. For example `float(3)` is `3.0`. Similar to `int` if the argument cannot be converted then a run-time error will result. For example `float('hello')`.


Here is our modified program

[source,python]
f = float(input('Enter a temperature (F): ')) <1>
c = 5/9*(f - 32)
print(f, "degrees fahrenheit is", c, "degrees celsius")

<1> Notice the use of the function `float` to convert the string to a floating-point number. 

Here is a sample run of the Fahrenheit to Celsius conversion program.

 Enter a temperature (F): 83.5 <1>
 83.5 degrees fahrenheit is 28.61111111111111 degrees celsius

<1> The user entered `83.5`

Notice the rather unhelpful number of digits in the result `28.61111111111111`. It looks rediculous. Python has a builtin function `round` that rounds a floating-point number to a certain number of decimal places. For example, `round(3.157, 2)` will round `3.157` to two decimal places, producing the value `3.16`. Using this in our temperature conversion program:

[source,python]
f = float(input('Enter a temperature (F): '))
c = 5/9*(f - 32)
print(f, "degrees fahrenheit is", round(c,1), "degrees celsius") <1>

<1> Notice the use of the function `round` to round th value `c` to one decimal places.

Here is a sample run of the Fahrenheit to Celsius conversion program.

 Enter a temperature (F): 83.5
 83.5 degrees fahrenheit is 28.6 degrees celsius
 
NOTE: There are two different kinds of functions in Python, those that _return_ values, and those that do not return a value but peform some other side effect. `print` is an example of a function that does not return a value but has the the side effect of printing to the console window. Contrast this to the `round` function which returns a rounded result.

image::round.png[align="center"]

==== Program Flow

Python programs execute line-by-line top-to-bottom. Variables must be defined and assigned 
values before those values can be used. Consider the previous celsius-to-fahrenheit conversion program. 

. The first assignment statement +
`f = float(input('Enter a temperature (F): '))` +
that executes defines the variable `f`. +
. The second statement +
`c = 5/9*(f - 32)` +
defines `c` _by using_ the variable `f`
. The third statement +
`print(f, "degrees fahrenheit is", round(c,1), "degrees celsius")` <1> +
prints the result using both `c` and `f`

=== The `math` module
 
Python has lots of support libraries that we can use to get our work done. Think of 
a support library as predefined functions that you can call on. One such support library is called the _math module_. The math module contains lots of functions and some predefined constants. For example `math.sin(x)` computes the _sin_ of the argument _x_ (where _x_ is in radians).   

NOTE: A _module_ is a named collection of related frunctions and definitions. Modules can be hierarchical, that is we can have modules defined inside other modules. Much like on your computer where yo can have folders inside folders to organize your documents.

To use the functions and definitions in the math module your program first needs to tell Python that we need it using an _import statement_.

[source,python]
import math

One way to compute the square root of a number would be just to raise to the 1/2 power. 

[source,pyhon]
print(2**.5)

Another way would be to use the math module's square root function.

[source,python]
print(math.sqrt(2))

TIP: `import` is a Python _keyword_. A keyword is a word reserved for use by Python. 
As such you should never use a keyword as a variable name (in fact that is an error). 

A constant defined in the math module is `math.pi`

[source,python]
----
print(math.pi)
----

[source,console]
----
3.141592653589793
----

NOTE: To reference functions and definitions in a module use _dot notation_. For example, `math.pi`, `math.sqrt(x)`.

==== Function Composition

A powerful programming technique is to call a function and use its return result as an argument in another function call. This is called _function composition_. Mathematically if stem:[f] and stem:[g] are functions that return a result we can _compose_ them as stem:[f(g(x))]. 

For example, if we needed to compute stem:[sin(\sqrt{\pi/4})] ...

image::function-composition.png[align="center"]

.Version 1
[source,python]
result = math.sin(math.sqrt(math.pi/4)) <1>
print(round(result, 2)) <2>

<1> This is the function composition of `math.sin` and `math.sqrt`.
<2> Here we are composing `print` and `round`

We could have done all this in one (albeit less readable) line ...

.Version 2
[source,python]
print(round(math.sin(math.sqrt(math.pi/4)), 2))

Or we could have also broken it up into more statements ...

.Version 3
[source,python]
result1 = math.sqrt(math.pi/4)
result2 = math.sin(result1)
result3 = round(result2, 2) 
print(result3)

These are all equivalent and one is not necessarily better than the other. A fourth version reuses the `result` variable in each statement and does not define new variables.

.Version 4
[source,python]
result = math.sqrt(math.pi/4)
result = math.sin(result)
result = round(result, 2) 
print(result)

We will see over and over that there are many ways to express the same computation, some may be better than others because they are more readable or more efficient.

https://docs.python.org/3/library/math.html[Python math module documentation]
 
=== Kinds of Program Errors

We have already discussed _syntax errors_ and _run time errors_. 

Recall that a syntax error is an error in how you string together the words and characters of your program. For example, a missing parentheses, or quote in a string literal, etc.  Syntax errors can be detected _before_ you run the program and are often highlighted in whatever IDE.footnote:[Integrated Development Environment. An IDE integrates into one tool an editor in which you edit, run,and debug your Python programs.] you are using. 

A _run-time_ error are errors that cannot be detected before program execution and only occur while your program is executing. Common run-time errors include divding by zero, or using a variable before it is defined. For example, consider the following simple (and silly) program:

[source,python]
----
s = int(input("Enter a number: "))
print("1000 divided by", s, "is", 1000/s) 
----

What would happen if the user entered a 0 at the input prompt? There is no way for python to know what the user is going to type and if they enter a 0 then the program will _crash_.

==== Logic Errors
There are even more insidious and difficult to find errors. At least with a syntax error the IDE will tell you where in the code the error is, and when you have a run-time error python will tell you exactly which line caused the crash. 

Lets revisit our celsius to fahrenheit conversion program.  The program below does not contain a syntax error nor does it contain a run-time error. There is, however, a problem with it. Can you see it?

.Logic error
[source,python]
----
f = float(input('Enter a temperature (F): '))
c = 5/9 * f-32
print(f, "degrees fahrenheit is", round(c,1), "degrees celsius")
----

[.result]
====
There are parentheses missing around the `f-32`. This program executes just fine and produces a result, it is just the wrong result. This kind of error is a _logic error_. A logic error is an error where the program produces an incorrect result when it executes. 
====

=== Bits, CPUs, Interpreters, and Compilers

Place holder to talk about computers, ...

=== Exercises

.C2F 
Write a program that converts a temperature in celsius to fahrenheit. Prompt the user for the temperature and print the conversion rounded to two decimal places.  Make the output 
neat and descriptive.

.Windchill
Write a Python program that calculates the wind chill temperature stem:[W] given the current temperature stem:[t] (in Fahrenheit) and the wind velocity stem:[v] (in MPH). The current temperature and the wind velocity should be entered by the user from the keyboard. +
The https://www.weather.gov/media/epz/wxcalc/windChill.pdf[formula the National Weather Service uses] to calculate wind chill temperature is:

stem:[W = 35.74 + 0.6215t + (0.4275t - 35.75)v^{0.16}]

 Enter temperature (F): 32.0
 Enter wind velocity (MPH): 10.0

 The wind chill for 32.0 degrees with a
 wind velocity of 10.0 MPH is 23.7 degrees.

Print the result rounded to one decimal place, like the `23.7` above.

.Area of circle
The area of a circle with radius stem:[r] is stem:[area = \pi r^2].  Write a program that prompts the user for a radius and computes and computes and prints the area of the circle rounded to 3 decimal places.

.Volume of a Cone
The volume of a cone with height stem:[h] and radius stem:[r] is stem:[v = \pi r^2h/3]. Write a Python program that will read the radius and the height from the user and computes and prints the volume of the cone.

.Population Growth
In the United States there is a birth every 8 seconds, a death every 12 seconds, and a new immigrant (net) every 33 seconds.  The current population is roughly 325 million. Write a program that will promt the user for a number of years and print the estimated population that many years from now.

.Compound Interest
Assume that *_C_* is an initial amount of an investment, *_r_* is the yearly rate of interest (e.g., .02 is 2%), *_t_* is the number of years until maturation, *_n_* is the number of times the interest is compounded per year, then the final value of the investment is stem:[p=c(1+r/n)^{tn}]. Write a program that reads *_C_*, *_r_*, *_n_*, and *_t_* from the user and computes and then prints the final value of the investment to the nearest penny.

.Change Making 
Write a prgram that reads an amount of money that we need to make change for, and dispenses
the correct amount of change (in U.S. currency). Assume that the 20 dollar bill is the largest denomination.  Here is an example execution of the program ...

----
Enter an amount to make change for: 78.98

Your change is...

3 twenties
1 ten
1 five
3 ones
3 quarters
2 dimes
0 nickels
3 pennies

---- 

.Distance from origin
The distance of a point _(x,y)_ from the origin, by the Pythagorean theorem is stem:[d=\sqrt{x^2+y^2}]. Write a program that reads an _x_ and a _y_ from the user and computes the distance of the point from the origin.

.Distance between two points
The distance _between_ two points _(x~1~,y~1~)_ and _(x~2~,y~2~)_ is also easily derived usingthe Pythagorean theorem. It is stem:[d=\sqrt{(x_2-x_1)^2 + (y_2-y_1)^2}]. Write a program that reads two points from the user and computes and prints the distance between the two points.

'''

=== Terminology

Every discipline has its own terminology (or _nomenclature_). Terminology is what allows us to _communicate intelligently with accuracy and precision_ about a discipline both amongst other programmers and to the lay-person. 

TIP: Master the terminology. Every term below is defined somewhere in this text. Just search for it in the browser.

.Terminology
[cols="2"]
|===

a| 
* computer science
* string literal (constant)
* integer literal (constant)
* floating-point literal (constant)
* builtin function
* function call
* variable
* _Hello World_ program
* scientific notation
* programming language
* comment
* crash
* prompt
* CPU
* interpreter
* domain (of a function)

a|
* argument
* expression
* value
* syntax error
* run-time error
* function
* keyword
* module
* escape character
* assignment statement
* function composition
* logic error
* bit
* compiler
* range (of a function)

|===

.Functions

We have encountered several functions this chapter.

* `print(arg1, arg2, ...)` +
+
`print` does not produce a value but has the side effect of printing the values `arg1`, `arg2`, ... to the console.
+
* `round(v, n)` -> `float` 
+
`round` expects a float to that will be rounded to `n` decimal places. The rounded float is returned.
+
* `math.sqrt(v : float)` +
+
`math.sqrt` in the math module computes and returns the square root of `v`.
+
* `int(x)`
+
If `x` is a float then return the integer part of `x` by truncating the decimal part. If `x` is a string then attempt to convert the string to an integer. If it can't then error.
* `float(x)`
If `x` is an integer then convert it to a float. If `x` is a string then attempt to convert it to a float. If it can't then error.
* `input(prompt)` + 
+
print the string `prompt` to the console and wait for keyboard input. Return the string the user entered. No type conversion takes place. For example if the user types 3.14 then the string "3.14" is returned.

== Pygame Intro

A fun way to learn to program is through graphics, images, and animation.  https://www.pygame.org/news[Pygame] is a popular python library (module) for implementing graphics in Python programs. As the name suggests, Pygame can used for programming computer games, but we can also use its graphics capabilities to explore programming in Python and various topics in computer science.

To use pygame there is some standard code we need at the start of every program (but only in programs that use pygame).

.hello_pygame.py
[source,python]
----
import pygame <1>
pygame.init() <2>
win = pygame.display.set_mode((600,600)) <3>
----

<1> import the pygame module
<2> Call a pygame function `init` that initializes pygame. The `init` function takes no arguments and does not return a value. The parentheses are necessary to indicate that this is a function call.
<3> Construct a window, 600 pixels wide and 600 pixels high. The `set_mode` function is part of the `display` module that is in the `pygame` module. Notice the double parentheses. The `set_mode` function takes one argument, but that argument needs to be a _tuple_ that represents the width and the height of the window in pixels. `set_mode` returns a _reference_ to the window. `win` is a variable that refers to a pygame _display surfce_.

When we run the program above a window will display on our monitor and then quickly vanish. The window disappears because the program finished. We probably don't want the window to disappear right away.

NOTE: A _tuple_ is an ordered pair (or triple, or quadruple, etc.). A tuple in python is two or more values wrapped up into using parentheses with the values separated by commas. For example the tuple `(200,300)` represents a single value with two integer components.

NOTE: A _pixel_, short for _picture element_, represents a single dot on the screen. A typical display has a _resolution_, which might be stem:[1024 \times 768] (1024 pixels wide by 768 pixels high) or stem:[1472 \times 1193].  A pixel has a physical dimension that depends on the size of the display.  The word _pixel_ is sometims abbreviated _px_.

NOTE: Most of the variables we have encountered so far have held integers or floats. The variable `win` above represent a _reference_ to a window. For now, think of a reference as being a variable that refers to a complex object such as a window.  
.`x` is primitive and `win` is _reference_ +
image:references.png[width=500,align="center"]


.Waiting +++<span style='color:red;margin-right:1.25em; display:inline-block;'>&nbsp;&nbsp;&nbsp;</span>+++
Can you think of a way we might be able to pause the program to keep the window from disappearing until the user hits a key on the keyboard?

[.result]
====
The `input` function waits for the user to type something on the keyboard and hit enter.

.hello_pygame.py
[source,python]
----
import pygame 
pygame.init() 
win = pygame.display.set_mode((600,600)) 
dummy = input("Hit <enter> to quit.") <1>
----
<1> We don't need the `dummy` variable since we aren't going to use what the user typed. We could have just said ...

[source,python]
----
input("Hit <enter> to quit.")
----
====

=== Colors

Before we talk about drawing shapes on the window we need to know how to represent a color. A common color scheme is called RGB, short for Red-Green-Blue. In pygame a color is a triple of three values where (0,0,0) represents black all the way up to (255,255,255) which is white. There are roughly 16 million different colors we can represent. [red]*Red* is (255,0,0), [green]*green* is (0,255,0), and [blue]*blue* is (0,0,255). Yellow is red and green, so that would be (255,255,0).

NOTE: There are many online tools to help determine the RGB values for various colors. Most development environments have one too. Just do an internet search for RGB colors, or color picker.footnote:[A popular _Integerated Development Environmnet_ is https://www.jetbrains.com/pycharm/[Pycharm] from https://www.jetbrains.com[Jetbrains]. Pycharm has a builtin Color Picker. There is a free Ecommunity Edition of Pycharm or students and faculty can obtain a free license for the Professional version.  ]

One common thing many of our pygame programs will do is to define some colors. 

.color.py
[source,python]
----
# file color.py
red    = (255,0,0)
green  = (0,255,0)
blue   = (0,0,255)
yellow = (255,255,0)
white  = (255,255,255)
black  = (0,0,0)
aqua   = (0,255,255)
burntsienna = (138,54,15)
lightgray = (200,200,200)
----	

We will soon get tired of retyping these definitions in our pygame programs. One thing we can do is to place these color definitions in their own file and name is `color.py`.
We can then import `color.py` into our pygame program and voila! we have created our own python module named `color` and we can reuse our color definitions without having to retype them every time.

TIP: Put commonly used code in a separate file and import that file into each program that needs it. This allows you to reuse code rather than duplicate it. 

.hello_pygame.py
[source,python]
----
import color   # this is the color.py file we just wrote above
import pygame

pygame.init() 
width = 600
height = 500
win = pygame.display.set_mode((width,height)) <1> 
win.fill(color.burntsienna) <2>
pygame.display.update() <3>
input("Hit <enter> to quit.") <4>
----
<1> `win` (short for window) is a _display surface_ in pygame. We did not have to call it `win`. We could have called it any legal variable name.

<2> Our first pygame drawing command `win.fill` takes one argument that is an RGB color triple and fills the window with the color `burntsienna` from our color module.

<3> When pygame functions draw on the display the window is not actally updated until we call the pygame function `pygame.display.update()`. 

<4> Wait for the user to hit enter so the window doesn't disappear right away.

=== Shapes

In this section we are going to introduce how to draw a circle, ellipse, rectangel, line, and a single pixel on a surface.

==== Rectangle 

The pygame function `pygame.draw.rect` draws a rectangle on a surface and takes either three or four arguments.

NOTE: Pygame programs only ever have one display surface. We will se later on that our pygame programs may have multiple surfaces (such as an image) that we will render on a display surface.

+++
<code class="listingblock">
pygame.draw.rect(<i>surface</i>, <i>color</i>, <i>xywh</i>, <i>optional-line-width</i>)
</code>
+++

_surface_:: The surface we are going to draw the rectangle on. For now we will just use the display surface `win` that was constructed using the `set_mode` function.

_color_:: An RGB triple such as (0, 255, 255) or color.yellow (from our color module)

_xywh_:: A four tuple (quadruple) that represents the _x_ and _y_ coordinate of the upper left hand corner of the rectangle and the width _w_ and the height _h_ of the rectangle. All units are in pixels.

_optional-line-width_:: If this argment is left off then the rectangle is filled in with the specified color. If it is specified then it takes a width, in pixels, of the border of the rectangle. 

CAUTION: The upper left coordinate of the surface is the origin (0,0). 

.Example +++<span style='color:red;margin-right:1.25em; display:inline-block;'>&nbsp;&nbsp;&nbsp;</span>+++
Draw a yellow rectangle that is one third the width of the display surface and one third the height in the center of the display. Hint: draw this out on a sheet of paper. It is a little trickier than you think. Here is a diagram to get you started.

[.result]
====
[source,python]
----
import pygame, color

pygame.init()
width = 600   # display surface 600 pixels wide
height = 400  # display surface is 400 pixels high
win = pygame.display.set_mode((width,height))

win.fill(color.lightgray)

# set up some variable for the rectangle
r_width = width//3
r_height = height//3
r_x = width//2 - r_width//2
r_y = height//2 - r_height//2
pygame.draw.rect(win, color.yellow, (r_x,r_y,r_width,r_height))
pygame.display.update()

input("Hit <enter> when done")
----
====

image::pygame-rect-window.png[width=533,height=367,align="center"]

Notice the use of _integer division_ `//`. All of the pygame functions take integer arguments. Intuitively, when calculating dimensions or coordinates it doesn't mak sense to do this in fractions of a pixel. 

.Self Check

Assume we have a 600 X 400 pygame display.

.Top Left+++<span style='color:red;margin-right:1.25em; display:inline-block;'>&nbsp;&nbsp;&nbsp;</span>+++
What is the coordinate of the top left pixel in the pygame window?

[.result]
====
(0,0)
====

.Top Right+++<span style='color:red;margin-right:1.25em; display:inline-block;'>&nbsp;&nbsp;&nbsp;</span>+++
What is the coordinate of the top right pixel in the pygame window?

[.result]
====
(599,0)

Now,most likely what you said was (600,0). This is a common mistake, Remember
the window is 600 pixels wide and we are starting counting at 0. So the 600th pixel
is column 599. This mistake of being off by one, computer scientists quite literally call an _off by one error_.
====

.Bottom Left+++<span style='color:red;margin-right:1.25em; display:inline-block;'>&nbsp;&nbsp;&nbsp;</span>+++
What is the coordinate of the top right pixel in the pygame window?

[.result]
====
(0,399)
====

.Bottom Right+++<span style='color:red;margin-right:1.25em; display:inline-block;'>&nbsp;&nbsp;&nbsp;</span>+++
What is the coordinate of the top right pixel in the pygame window?

[.result]
====
(599,399)
====

.Proportional Graphics
Notice that our yellow square is _proportional_ and relative to the size of the main pygame display surface. That is, if we change the size of the main display surface the yellow square will resize accordingly. Most often this is the kind of graphics that we want and is one of the powerful features of doing graphics using geometric shapes. The name for this kind of graphics, using geometric shapes, is _vector graphics_.

TIP: Try and always use _proportional graphics_. In proportional graphics a shape is drawn relative to some enclosing shape. For example an eye would be drawn relative to a head, and a pupil would be drawn relative to the eye. If we were drawing a house, a door's dimensions would be relative to the house's dimensions.  

Constrast this with using _absolute dimensions_ and _absolute pixel coordinates_. For example, if we draw a yellow rectangle at coordinate (100,200) with a width of 300 px and a height of 200 px.

[source,python]
pygame.draw.rect(win, color.yellow, (100,200,300,200))

then this woould draw the same sized yellow rectangle in the same place no matter if our display was 400 X 400 or 1000 X 1000.  Worse yet if the display was 200 x 200 the yellow square would not even fit in the display. 

Graphics using individual pixels only called _raster graphics_.

==== Circle

The pygame function `pygame.draw.circle` draws a circle on a surface and takes either four or five arguments.

+++
<code class="listingblock">
pygame.draw.circle(<i>surface</i>, <i>color</i>, <i>xy</i>, radius, <i>optional-line-width</i>)
</code>
+++

_surface_:: The surface we are going to draw the rectangle on. 

_color_:: An RGB triple

_xy_:: A tuple that represents the _x_ and _y_ coordinate of the _center_ of the circle.

_optional-line-width_:: If this argment is left off then the circle is filled in with the specified color. If it is specified then it takes a width, in pixels, of the border of the circle.

Lets draw a dark gray circle centered in the upper left quadrant of the yellow sqaure. We will do this proportionally, making the diameter of the sircle 1/3 width of the quandrant. Calculating the `x` and `y` coordinates of the circle can be a little tricky. The width of the quadrant is `r_width//2`

The x coordinate of the circle is relative to `r_x`, the x coordinate of the yellow rectangle. Add in 1/2 the width of the quadrant you get
 
[source,python]
ul_c_x = r_x + r_width//4   # ul_c_x is short for upper left circle x coordinate

Similarly the y coordinate is 

[source,python]
ul_c_y = r_y + r_height // 4

Remember that the circle fcuntion requires the radius but the problem stated that the 
diameter of the circle is 1/3 the width of the quadrant. We know the width f the quadrant is `r_width//2` and 1/3 od that is `r_width//2//3` and a radius is still 1/2 of that, so we are left with

[source,python]
ul_c_radius = r_width// 2 // 3 // 2 # or r_width // 12 

Defining a new color `darkgray = (100,100,100)` in our color module and putting it all together we have 

[source,python]
ul_c_x = r_x + r_width // 4
ul_c_y = r_y + r_height // 4
ul_c_radius = r_width//2//3//2  # width of quadrant is r_width//2 then 1/3 of that
pygame.draw.circle(win, color.darkgray, (ul_c_x,ul_c_y), ul_c_radius)

And we should get something that looks like

image::upper-left-circle.png[width=300,height=200,align="center"]

.Exercise +++<span style='color:red;margin-right:1.25em; display:inline-block;'>&nbsp;&nbsp;&nbsp;</span>+++
Draw another dark gray circle with the same radius centered in the upper right quadrant of the yellow rectangle.

[.result]
====
The only thing that changes is the x coordinate. The y coordinate and the radius
of the upper right circle are the same as the y coordinate and readius f the upper left circle. One way to think about the x coordinate is that is 3/4 of the width of the rectangle. 

[source,python]
----
ur_c_x = r_x + 3*r_width//4
ur_c_y = r_y + r_height // 4    # same as upper left circle
ur_c_radius = r_width//2//3//2  # same as upper left circle
pygame.draw.circle(win, color.darkgray, (ur_c_x, ur_c_y), ur_c_radius)
----

image::upper-right-circle.png[width=300,height=200,align="center"]

====
 
.Complete program +++<span style='color:red;margin-right:1.25em; display:inline-block;'>&nbsp;&nbsp;&nbsp;</span>+++
Here is the complete program so far with the two circles in the rectangle.

[.result]
====
[source, python]
----
pygame.init()
width = 600   # display surface 600 pixels wide
height = 400  # display surface is 400 pixels high
win = pygame.display.set_mode((width,height))

win.fill(color.lightgray)

# set up some variable for the rectangle
r_width = width//3
r_height = height//3
r_x = width//2 - r_width//2
r_y = height//2 - r_height//2
pygame.draw.rect(win, color.yellow, (r_x,r_y,r_width,r_height))

ul_c_x = r_x + r_width // 4
ul_c_y = r_y + r_height // 4

# width of quadrant is r_width//2 then 1/3 of that is
# the diameter, then 1/2 of that for the radius
ul_c_radius = r_width//2//3//2  
pygame.draw.circle(win, color.darkgray, (ul_c_x,ul_c_y), ul_c_radius)

ur_c_x = r_x + 3 * r_width // 4
ur_c_y = r_y + r_height // 4
ur_c_radius = r_width//2//3//2  # width of quadrant is r_width//2 then 1/3 of that
pygame.draw.circle(win, color.darkgray, (ur_c_x,ur_c_y), ur_c_radius)

pygame.display.update()

input("Hit <enter> when done")
----
====
 
[WARNING]
====
Notice the line for calculatig the x-coordinate of the upper right circle

 ur_c_x = r_x + 3 * r_width // 4

where we specified that it three-fourths thw width of the rectangle. You might be tempted to write

 ur_c_x = r_x + 3 // 4 * r_width

Why is the incorrect? Because `3//4` is 0!
====
 
 
==== Ellipse

An ellipse is an oval shape with a width and a height. In graphics an ellipse is very similar to a rectangle. In fact the function to draw an ellipse is almost execatly the same as the function to draw a rectangle.  The one part of drawing an ellipse that takes
some getting used to it that the `(x,y)` coordinate of the ellipse is the `(x,y)` coordinate of the rectangle (or _bounding box_) that surrounds the ellipse.

image::ellipse.png[align="center"]

+++
<code class="listingblock">
pygame.draw.ellipse(<i>surface</i>, <i>color</i>, <i>xywh</i>, <i>optional-line-width</i>)
</code>
+++

_surface_:: The surface we are going to draw the ellipse on.

_color_:: An RGB triple

_xywh_:: A four tuple (quadruple) that represents the _x_ and _y_ coordinate of the upper left hand corner _bounding box_, abd the width _w_ and the height _h_ of the ellipse.

_optional-line-width_:: same as rectangle and circle functions.

These are, in fact, the same arguments for drawing a rectangle.

Continuing our program from before lets draw a pink ellipse centered in the x axis, 3/4 the width of the rectangle and two-thirds of the way down the height of the rectangle. Add `pink = (255, 20, 147)` to our `color.py` module.


[source,python]
----
e_width = r_width // 2
e_height = r_height // 4
e_x = r_x + r_width // 2 - e_width // 2
e_y = r_y + 2 * r_height // 3
pygame.draw.ellipse(win, color.pink, (e_x,e_y,e_width,e_height))
----

Adding this code to our running example we should get something like ...

image::ellipse2.png[width=300,height=200,align="center"]

You have probably guessed by now that what is taking shape is a face, a Mr. or Mrs. Blockhead.

.Exercise +++<span style='color:red;margin-right:1.25em; display:inline-block;'>&nbsp;&nbsp;&nbsp;</span>+++
Use an ellipse to add a nose above the mouth. +
image:nose.png[width=300,height=200,align="center"]

[.result]
====
There are lots of ways to do this, but you need to make it relative to the head. 
[source,python]
----
n_width = r_width // 10  # 1/10th width of head
n_height = r_height // 4 # 1/4 height of head
n_x = r_x + r_width // 2 - n_width // 2  # centered horizontally
n_y = r_y + r_height // 2 - n_height//2  # centered vertically
pygame.draw.ellipse(win, color.blue, (n_x,n_y,n_width,n_height))
----
====

.Exercise +++<span style='color:red;margin-right:1.25em; display:inline-block;'>&nbsp;&nbsp;&nbsp;</span>+++
You can give the Blockhead a smil by drawing an ellipse over the top of the mouth shifted up slightly, and make it the same color as the background head. +
image:smile.png[width=300,height=200,align="center"]

[.result]
====
This is one line, drawing an ellipse shifted up, say 20% of the width of the mouth.
[source,python]
----
pygame.draw.ellipse(win, color.yellow, (e_x, e_y, e_width, e_height - .2*e_height))
----
====

.Exercise
Give the Blockhead pupils by drawing a circle or ellipse in each eye. Make sure it is proportional!

TIP: You can always check to see if you are making your shapes proportional if you change the dimensions of the pygame display at the start of the program and make sure the image resizes appropriately.

==== Lines

You can draw a line in pyagme using the function `pygame.draw.line`.

+++
<code class="listingblock">
pygame.draw.line(<i>surface</i>, <i>color</i>, <i>start-xy</i>, <i>end-xy</i>, <i>optional-line-width</i>)
</code>
+++

_surface_:: The surface we are going to drawing the line on.

_color_:: An RGB triple

_start-xy_:: The (x,y) coordinate of one endpoint of the line

_end-xy_:: The (x,y) coordinate of the other endpoint of the line

_optional-line-width_:: The width of the line in pixels

.Exercise  +++<span style='color:red;margin-right:1.25em; display:inline-block;'>&nbsp;&nbsp;&nbsp;</span>+++
Draw a cross through the left eye. +
image:eye-cross.png[width=300,height=200,align="center"]

[.result]
====
[source,python]
----
pygame.draw.line(win, color.white,
                 (ul_c_x, ul_c_y - ul_c_radius),
                 (ul_c_x, ul_c_y + ul_c_radius))

pygame.draw.line(win, color.white,
                 (ul_c_x - ul_c_radius, ul_c_y),
                 (ul_c_x + ul_c_radius, ul_c_y))
----
====

There are other pygame drawing functions that we will introdce as needed. You can make an astonishing number of drawing from rectangles, circles, ellipses, and lines. 

.Our Complete Blockhead +++<span style='color:red;margin-right:1.25em; display:inline-block;'>&nbsp;&nbsp;&nbsp;</span>+++
Variables have been renamed to be more meaningful. FOr example `ul_c_x` which stood for (_upper left circle x coordinate_) is now `left_eye_x` and so on.

[.result]
====
include::python/blockhead.py[]
====

.Exercise
Complete the Blockhead adding ears, hair, a hat. Make sure it stays proportional. 

==== Sample Blockheads

To give you some ideas here are some of the blockheads that have been turned in over the years as assignments.footnote:[Thank you to Angelica Munyao, Sam Emerson, Ethan Cox, Elsa Feck, Yuxi Zhang, and Jack Pattison for allowing me to use their Blockhead submissions.]

.Example 1 +++<span style='color:red;margin-right:1.25em; display:inline-block;'>&nbsp;&nbsp;&nbsp;</span>+++
+++<span style='color:red;margin-right:1.25em; display:inline-block;'>&nbsp;&nbsp;&nbsp;</span>+++

[.result]
====
image::sbh.png[width=300,height=200,align="center"]
====

.Example 2 +++<span style='color:red;margin-right:1.25em; display:inline-block;'>&nbsp;&nbsp;&nbsp;</span>+++
+++<span style='color:red;margin-right:1.25em; display:inline-block;'>&nbsp;&nbsp;&nbsp;</span>+++

[.result]
====
image::minion.png[width=300,height=200,align="center"]
====

.Example 3 +++<span style='color:red;margin-right:1.25em; display:inline-block;'>&nbsp;&nbsp;&nbsp;</span>+++
+++<span style='color:red;margin-right:1.25em; display:inline-block;'>&nbsp;&nbsp;&nbsp;</span>+++

[.result]
====
image::pumpkin.png[width=300,height=200,align="center"]
====

.Example 4 +++<span style='color:red;margin-right:1.25em; display:inline-block;'>&nbsp;&nbsp;&nbsp;</span>+++
+++<span style='color:red;margin-right:1.25em; display:inline-block;'>&nbsp;&nbsp;&nbsp;</span>+++

[.result]
====
image::spongebob.png[width=300,height=200,align="center"]
====

.Example 5 +++<span style='color:red;margin-right:1.25em; display:inline-block;'>&nbsp;&nbsp;&nbsp;</span>+++
+++<span style='color:red;margin-right:1.25em; display:inline-block;'>&nbsp;&nbsp;&nbsp;</span>+++

[.result]
====
image::grumpy.png[width=300,height=200,align="center"]
====

.Example 6 +++<span style='color:red;margin-right:1.25em; display:inline-block;'>&nbsp;&nbsp;&nbsp;</span>+++
+++<span style='color:red;margin-right:1.25em; display:inline-block;'>&nbsp;&nbsp;&nbsp;</span>+++

[.result]
====
image::doodlebug.png[width=300,height=200,align="center"]
====

=== Terminology


.Terminology
[cols="2"]
|===

a| 
* pixel
* reference
* display surface
* off-by-one error
* vector graphics

a|
* tuple
* Integrated Development Environment (IDE)
* surface
* proportional graphics
* raster graphics

|===


=== Functions

* `pygame.init`
* `pygame.display.set_mode`
* `surface.fill`
* `pygame.display.update`
* `pygame.draw.rect`
* `pygame.draw.circle`
* `pygame.draw.ellipse`
* `pygame.draw.line`
* `pygame.draw.arc`

== Functions 

Functions play a massively important role in programming. They encapsulate common computations and keep programmers from having to reinvent the wheel.

Recall that in mathematics a _function_ maps values in a _domain_ to values in a _range_. In Python the `math.sqrt` function maps 4 to 2, 9 to 3, and 2 to 1.4142135...  

.`math.sqrt` function
image::sqrt-func.png[width=604,height=226,align="cener"]

The round function maps `round(3.56,1)` to `3.6`. *_Functions return values_*. Always. But sometimes we don't care about the return value. In Python functions sometimes return the special value `None` which, which essentially means the function does not "really" return a value.footnote[In other programming languages such as C and and Java these are called _void_ functions.]. For example, the `print` function returns the value `None` but has the _side effect_ of printing its arguments on the console.

.`print` function
image::print-func.png[width=604,height=226,align="cener"]

We saw earlier that 

[source,python]
----
print("Hello World")
----

will print _Hello World_ on the console, but `print` also returned the `None` value.

The following looks strange, but is legit, and almost certainly not what was intended.

[source,python]
---- 
print(print("Hello World"))
----

.Self Check +++<span style='color:red;margin-right:1.25em; display:inline-block;'>&nbsp;&nbsp;&nbsp;</span>+++
What would get printed by the code above?

[.result]
====

[source,python]
----
Hello World
None
----

The inner `print` prints _Hello World_ to the console and returns `None` to the outer `print`, which it prints the console. Again, strange, and almost certainly not what was intended. 

====

TIP: `None` is an actual value in Python like `3` and `3,14` and `"Hello"`. It is the value that means _no value_. You will rarely every use it explicitly.

=== Calling Functions

Lets get a little more formal about calling functions. Consider the statement

[source,python]
print("Hello World")

We say that we are _calling_ the `print` function and _passing_ the argument `Hello World`. Passing an argument means we send the value to the function.

Consider our previous program where we needed to compute stem:[sin(\sqrt{\pi/4})] ...

[source,python]
----
result = math.sin(math.sqrt(math.pi/4))
print(round(result, 2))
----

.Self Check +++<span style='color:red;margin-right:1.25em; display:inline-block;'>&nbsp;&nbsp;&nbsp;</span>+++
How many function calls are there? Explain all of the arguments and return values.

[.result]
====
The first line contains two function calls. First `math.sqrt` is called with the argument `math.pi/4`. Then `math.sin` is called and uses the _return value_ from the `math.sqrt` call as its arguments. The return value of `math.sin` is then assigned to the variable `result`. The second line contains two function calls as well. First `round` is called with _two_ arguments, `result` and `2`. `result` is the value being rounded and `2` is the number of places to round to. The return value from `round` is then used as the only argument to the `print` function. 

In total there are four function calls and five arguments involved.
====

=== Defining Functions

The real power with functions is that we get to define our own. Functions allow us to encasulate of commonly occurring computation. Lets go back to our rather banal example of our formula to convert a fahrenheit temperature to celsius. Rather than having to keep remember the formula we can just define a function.

.util.py
[source,python]
----
def f2c(f): <1>
    c = 5 / 9 * (f - 32) <2>
    return c <3>
----
	
<1> This is the _function header_. It tells Python we are defining our own function and it takes one _parameter_ `f`. The value of `f` is determined by the argment when `f2c` is called.
<2> This is the main part of the function that does the computation. It defines a _local variable_ `c`.
<3> This is the return statement that indicates that function `f2c` returns the value `c` to the _caller_ that was just computed.

Lines 2 and 3 constitute the _function body_, which is indented under the function header.

We now have our own function for converting fahrenheit to celsius and we can tuck it away in a file somewhere so we can reuse it later.

image::f2c-func.png[align="center"]

We can use `f2c` in a program by _calling_ it with an argument.

[source,python]
----
print(f2c(32))
----

We call this the _main program_. The main program is any code that exists outside of 
a function.

.Self check +++<span style='color:red;margin-right:1.25em; display:inline-block;'>&nbsp;&nbsp;&nbsp;</span>+++
Why is the following line incorrect? +
`f2c(32)`

[.result]
====
Because `f2c` returns a value, and this line does not do anything with that value. It doesn't print it or use it in another computation.
====

It is a common mistake for students to confuse a function _returning a value_ and a _function printing a value_. Consider this version of `f2c`.

[source,python]
----
def f2c(f):
    c = 5 / 9 * (f - 32)
    print(c)
----

This function returns the value `None` and, as a side effect, prints the value of the variable `c` on the console. This function is not technically wrong. It does not have a syntax error, nor a run-time error, or even a logic error. But it is in some way inferior to the first version of `f2c`. Consider the following program.

[source,python]
----
t = float(intput("Enter a temperature: "))
print(f2c(t) +  100)
----

This program reads a temperature from the user and puts it in the variable `t`. It then converts `t` to celsius and add 100 degrees celsius to the result and printing the final value. For the first version of `f2c` this works fine. But the second version crashes because it tries to add 100 to `None`.
 
WARNING: A function that returns a value is not the same thing as the function printing a value. 

==== Putting function in a module

Since we will be using the `f2c` function later in the text it is a good idea to place general functions in a module, such as `util.py`.

[source,python]
----
import util 

t = float(intput("Enter a temperature: "))
print(util.f2c(t) +  100)
----

=== Functions for their side effect

Functions return values. Some functions, such as `print`, return `None` but are used for their _side effect_.  
 
Recall our complete blockhead program from before. 

.Our Complete Blockhead +++<span style='color:red;margin-right:1.25em; display:inline-block;'>&nbsp;&nbsp;&nbsp;</span>+++
+++<span style='color:red;margin-right:1.25em; display:inline-block;'>&nbsp;&nbsp;&nbsp;</span>+++

[.result]
====
include::python/blockhead.py[]
====

What if we wanted to draw two or more blockheads on the display surface? One way is to make another copy of the code, and change lots of variable names etc. This is a perfect situation where we can write a function `blockhead` that we can call more than once. 

In keeping with the way drawing rectangle works specifying the Blockhead's x and y coordinate along with its width and height makes sense:

[source,python]
----
def draw_blockhead(head_x, head_y, head_w, head_h):
    pass
----
	
This is just the function header. Notice the use of the Python statement `pass`. This is the statement that does nothing. We are using it here as a placeholder for the function body.

So what we'll do now is place all of the code used for the drawing inside the function and make sure that we use the parameters to initilize the 

[source,python]
----
def draw_blockhead(head_x, head_y, head_w, head_h):

    pygame.draw.rect(win, color.yellow, (head_x, head_y, head_width, head_height))

    # left eye
    left_eye_x = head_x + head_width // 4
    left_eye_y = head_y + head_height // 4
    left_eye_r = head_width // 12
    pygame.draw.circle(win, color.darkgray, (left_eye_x, left_eye_y), left_eye_r)

    # left eye cross
    pygame.draw.line(win, color.white,
                     (left_eye_x, left_eye_y - left_eye_r),
                     (left_eye_x, left_eye_y + left_eye_r))

    pygame.draw.line(win, color.white,
                     (left_eye_x - left_eye_r, left_eye_y),
                     (left_eye_x + left_eye_r, left_eye_y))

    # right eye
    right_eye_x = head_x + 3 * head_width // 4
    right_eye_y = head_y + head_height // 4
	
	right_eye_r = head_width // 12  
    pygame.draw.circle(win, color.darkgray, 
	    (right_eye_x, right_eye_y), right_eye_r)

    # mouth
    mouth_width = head_width // 2
    mouth_height = head_height // 4
    mouth_x = head_x + head_width // 2 - mouth_width // 2
    mouth_y = head_y + 2 * head_height // 3
    pygame.draw.ellipse(win, color.pink, 
	    (mouth_x, mouth_y, mouth_width, mouth_height))

    # smile
    pygame.draw.ellipse(win, color.yellow, 
	    (mouth_x, mouth_y, mouth_width, mouth_height - .2 * mouth_height))

    # add a nose
    nose_width = head_width // 10  # 1/10th width of head
    nose_height = head_height // 4 # 1/4 height of head
    nose_x = head_x + head_width // 2 - nose_width // 2 
    nose_y = head_y + head_height // 2 - nose_height // 2  
    pygame.draw.ellipse(win, color.blue, 
	    (nose_x, nose_y, nose_width, nose_height))
----

Now we can call the `draw_blockhead` function as many times as we like without having to 
duplicate lots of code. The variables `head_x`, `head_y`, `head_w`, `head_h` are _parameters_ and they can be used anywhere in the function body. That is their _scope_.

NOTE: The _scope_ of a variable is the region of the progrsm where it can be used.

All of the other variables that are defined in the function are _local variables_. A local variable's scope is from the point where where it is defined until the end of the function.

NOTE: A _local variable_ is defined in the function. Its scope is th point from where it was defined until the end of the function.

Noteice that the `draw_blockhead` function still uses the variable `win`, which is neither passed as a parameter nor is it defined with the function. The function assumes `win` is defined in the main program. We say that `win` is a _global variable_.

NOTE: A _global variable_ is defined in the main program. Its scope is the point from where it was defined until the end of the program.

[source,python]
----
# initial pygame stuff
import pygame, color

pygame.init()
width = 600   # display surface 600 pixels wide
height = 400  # display surface is 400 pixels high
win = pygame.display.set_mode((width,height))

# create the background
win.fill(color.lightgray)

blockhead(0,0,299,199)
blockhead(300,0,299,199)
blockhead(0,200,299,199)
blockhead(300,200,299,199)
pygame.display.update()

input("Hit <enter> when done")
----

image::four-blockheads.png[width=300,height=100,align="center"]
	

=== Benefits of functions

==== Functions make code more readable 

If you look at the main program above it is clear that the program draws four figures. If we didn't use a function and duplicated the code to draw the figures then it would be far less clear what is going on. 

==== Functions make code less buggy

Imagine had we not used a function and we found an error in the code, we would then have to fix that error in every place where the code was duplicated. WHen we use a function we just fix it once.

==== Functions make programs more concise

This one is obvious. We don't have to copy and paste code, and the program is much shorter.

==== Functions allow programmers to easily _reuse_ code.

Consider our fahrenheit-to-celsius conversion function `f2c` that we placed in a file `util.py`. We can reuse that functionwhenever we want without having to reinvent the wheel every time.

=== Exercises

.Exercise 1
Write a function `circ_area` that that takes the radius of a circle as a parameter and retrns the area of the circle.  Write a main program that reads the radius from the user (keyboard) and prints the area.

.Exercise 2
Answer questions about the program below. The lines are number 

[source,python]
----
x = 5                   <1>
y = 6                   <2>
z = 33                  <3>

def f(x):               <4>
   y = 9                <5>
   print(x + y + z)     <6>

print(x + y + z)        <7>
f(12)                   <8>
print(x + y + z)        <9>   
pass
----

. What is the output of the program?

. Which line contains a function header?

. Which line(s) constitute the main program?

. Is there a local variable defined anywhere? If so what is its scope?

. Does the function `f` return a value?

. Does the function `f` reference any global variables?

. Which lines constitute a function body?

. Are there any arguments used in the program? If so what and where are they? (tricky)

. Are there any parameters defined in the program? Explain.

. What does the last line do? The line that is not numbered.

=== Terminology

.Terminology
[cols="2"]
|===

a| 
* function call
* passing an argument
* parameter
* local variable
* function body
* main program

a|
* return value
* `None`
* global variable
* function header
* scope
* `pass`

|===



== Repetition - The While Loop

Lets assume we have a particle.footnote:[a circle in pygame, which might be a ball, a hockey pick, an electron, ... ] on a pygame display surface drawn halfway down the display and all the way to the left.

NOTE: We will often use the term _particle_ to represent any kind of moving object such as a baseball, a hockey puck, an electron, ...  

[source,python]
----
import color, pygame

pygame.init()
side = 500
win = pygame.display.set_mode((side,side))

# properties of the particle
radius = side//20
px = radius   # particle is all the way to the left
py = side//2  # and halfway down display
win.fill(color.white)

# draw the particle
pygame.draw.circle(win, color.blue, (px, py), radius)
pygame.display.update()
----

What if we wanted to draw another particle right next to the first? The next particle's x coordinate will be 2 radii (plural of radius) past the first particle's x coordinate.

[source,python]
px = px + 2 * radius
pygame.draw.circle(win, color.blue, (px, py), radius)

How about a third particle?

[source,python]
px = px + 2 * radius
pygame.draw.circle(win, color.blue, (px, py), radius)

And a fourth? ... well, you get the picture. We could keep copying and pasting until we have as many particles displayed as we need. This should feel wrong. And it is. What we want to do is repeat those two lines until the display is filled with particles.

image::particles.png[align="center"]

The _while loop_ repeats a body of code (indented) as long as some condition is true. The syntax is ...

[source,python,subs="quotes"]
----
while (*_condition_*):
    stmt
----

We want to keep repeating the two lines of code 

[source,python]
px = px + 2 * radius
pygame.draw.circle(win, color.blue, (px, py), radius)

as long as some condition is true. As long as the particle's right edge is to the left of the right side of the display.

[source,python]
----
while px + radius < side:
    px = px + 2 * radius
    pygame.draw.circle(win, color.blue, (px, py), radius)
----

Eventually `px + radius` will become greater than `side` and the loop condition becomes false and then the loop _terminates_.

=== Animation 

One modification is that we can _animate_ the particle moving across the screen smoothly. Rather than redraw the particle two radii, redraw shifted by just one pixel. We can also add a delay. Finally before we redraw the particle we can erase the display. This is a standard way of an animating an object:

. Erase the background
. Update the an object's position (for example, the particle's _x_ coordinate).
. Redraw the object
. introduce a slight delay to model the passage of time

[source,python]
----
while px + radius < side:
    win.fill(color.white)                                    <1>
    pygame.draw.circle(win, color.blue, (px,py), radius)
    pygame.display.update()
    pygame.time.delay(5)                                     <2>
    px = px + 1                                              <3>
----
<1> erase the screen, effectively erasing the particle
<2> delay 5 milliseconds
<3> moving 1 pixel at a time makes motion look smooth

NOTE: A _sprite_ is a more general term for a 2-dimensional object that is animated in a larger scene. Our particle is an example of a sprite.

=== Relational Operators

Python can compare two values using _relational operators_ such as _less than_ `<`. 

[cols="1,8", width="50%", options="header"]
.Relational Operators
|===
|Operator | operation
|`<`
|less than
|`<=`
|less than or equal to
|`>`
|greater than
|`>=`
|greater than or equal to
|`==`
|equal to
|`!=`
|not equal to
|===

.Exercise
Animate moving the particle to the bottom of the screen.

.Exercise
Animate moving the particle from right to left.

.Exercise
Aniate moving the particle to the top of the screen.

TIP: Whenever you find yourself copying and pasting the same lines of code over and over that is a sure sign that either 1) you should be encapsulating that code in a function, or 2) it should be repeating in a loop.

=== Counting Loops
A common loop pattern is to repeat a body of code an exact number of times.

.Example
Lets say we wanted to print a table of of powers of two up to _2^10^_.

[listing]
----
i   2^i
==========
0  | 1
1  | 2
2  | 4
3  | 8
...
10 | 1024
----

[source,python]
----
# table header
print("i     2^i")
print("=========")

i = 0                       <1>
while i <= 10:              <2>
    print(i, '\t|', 2**i)   <3>
    i = i + 1               <4>
----
<1> In a counting loop we almost always initialize a variable to 0. It is a _convention_ to use `i`, `j`, and `k` as a name for a counting variable.
<2> We want to include `10` in our table to se use `<=` here. Could we have also said `i < 11`? Yes.
<3> `'\t'` represents the tab character. Without it the table columns would not be lined up neatly. Recall our discssion of _escape_ characters back in the section on string literals.
<4> This increments the value of `i` by 1.  

Lets be careful how we interpret the statement `i = i + 1`. This is an _assignment statement_, not a statement in mathematics (which would be nonsense). The way to read this is _the new value of `i` gets the old value of `i` plus one_. 

.Think About
What would happen if we forgot the line `i = i + 1`? 

[.result]
====
Since `i` would never increment, the loop condition would never become false and the loop would never terminate. This is called an _infinite loop_. 
====

TIP: A _convention_ is something that is common practice. Stick with conventions as it makes code more readable.

.Loop Exercise
Print the integers from 1 to 10, one integer per line. 

.Loop Exercise
Print the integers counting down from 10 to 0. WHen you are done print "Blast off". Add a one second delay in between integers. Hint: use the `pygame.time.delay` function. How many milliseconds in a second?

=== Accumulating Loops
Another common loop pattern is to keep a running total. For example, lets compute the sum of the integers from stem:[1] to stem:[n]. That is, stem:[1 + 2 + 3 + \cdots + n] where _n_ is entered by the user.footnote:[forgetting for the moment that there is a closed form answer of stem:[n(n+1)/2] ]

[source,python]
----
n   = int(input("Enter n: "))   
i   = 1                          <1>
sum = 0                          <2>                        

while i <= n:                    <3>
    sum = sum + i                <4>
    i = i + 1                    <5>

print("The sum from 1 to", n, "is", sum)
----
<1> The loop counter. This could have started at 0 but including 0 in the sum doesn't change it.
<2> Keep track of the running total in `sum`.
<3> Make sure to include `n`
<4> This adds the current value of `i` to the running total in `sum`. Again, interpret this as the assgnment statement _the new value of_ `sum` _gets the old value of_ `sum` _plus_ `i`.
<5> Increment the loop counter


.Exercise 
Write a program that computes the average of non-negative numbers entered by the user. Quit reading numbers when the user has entered a negative number. Here is an example run of the program. Be careful, make sure you don't include the negative number in the average.
----
Enter a number: 3
Enter a number: 9
Enter a number: 7
Enter a number: 8
Enter a number: -1
The average is  6.75
----

.Answer +++<span style='color:red;margin-right:1.25em; display:inline-block;'>&nbsp;&nbsp;&nbsp;</span>+++
+++<span style='color:red;margin-right:1.25em; display:inline-block;'>&nbsp;&nbsp;&nbsp;</span>+++

[.result]
====
[source,python]
----
n   = float(input("Enter a number: "))
i   = 0
sum = 0

while n >= 0:
    i = i + 1
    sum = sum + n
    n = float(input("Enter a number: "))

average = sum / i
print("The average is ", round(average, 2))
----

This is actually a little tricky. Notice the first line. We read our first number _before_ the loop. Once we get into the loop we know that we must have entered a non-negative number. 

There is actually a subtle bug in this code that can sometimes lead to a crash. Can you find it?footnote:[Hint: What if the very first number the user typed in was negative?]
====

=== Exponential Growth (password length)

Why are longer passwords better than shorter passwords? It is obvious, longer passwords are harder to guess. But howmuch harder? Lets say we allowed passwords to contain 26 upper or lower case characters (that is 52 possibble alphabetic characters, in the English alphabet), ten digits 0 through 9, and 32 symbol characters `~!@#$%^&*()_-+={[}]"':;>.<,?/|\`. That is 94 possible distinct characters that can be used in a password.footnote:[A rather arbitrary number, 94, but it is probably close]  

There are stem:[94] one character passwords, stem:[94^2 = 8836] two character passwords, stem:[94^3 = 830584] three chaacter passwords, and so on, so that if a password was ten characters long there are stem:[94^{10} = 53861511409489970176] possible passwords or approximately stem:[5 \times 10^{19}]. 

Plotting stem:[94^i] where _i_ is the number of characters in the password gives us the graph:

image::94_to_the_i.png[width=480,height=360,align="center"]

This is an example of _exponential growth_ in the number of characters in the password. Notice how the graph explodes at between 8 and 10 characters (was it ever suggested that you make your passwords more than 8 characters long?)
So what are total number of passwords up to 10 characters long? We would have to include all of the nine character passwords, and the eight character passwords, etc. and compute the sum stem:[94^1 + 94^2 + 94^3 + \cdots + 94^{10}].

[source,python]
----
i = 1
sum = 0
while i <= 10:
    sum = sum + 94**i
    i = i + 1

print(sum)
----

which would print `54440667446151152650`, which is also just bigger than stem:[5.4 \times 10^{19}]. 

To emphasize the difference between say a six character password and a ten character password, let's say a hacker was trying to break into a system by trying all possible passwords. How long might it take? Lets say we had a powerful computer that could attempt 1 billion passwords per second. 

For a six character password that's stem:[94^6/10^9/60 \approx 11.5] minutes. That's to try all possibilities. On average we'll search about half the passwords,so on average it would take about 6 minutes.

For a ten character password,
we have stem:[94^{10}/10^9] seconds. Dividing by 60 to get minutes then another 60 to hours, then 24 to get days, then 365.25 to get years, we have stem:[94^{10}/10^9/60/60/24/365.25 = 1706] years! Again, this is to try them all, so on average we would find it after looking at half othe asswords, so it would only take about 850 years.

NOTE: a _brute force attack_ is one where an attacker tries all possible combinations of passwords.  The number of possible passwords grows exponentially with their length. As we saw, brute force attacks are most effective against short passwords.

=== Exponential growth (populations)

Exponential growth arises in more subtle ways. In the previous example we were raising the base of the exponent, _94_, to a fairly large power.  What if the base were small, but still greater than one? Lets use an example of world population growth rate, which is currently estimated to be _1.11_% (or .011) per year in 2017.footnote:[https://www.census.gov] 

Let stem:[t] be the current year and stem:[P_t] be the current population  at the beginning of year stem:[t]. So stem:[P_{t+1} = P_t + 0.011P_t] or, factoring out the stem:[P_t] then stem:[P_{t+1} = P_t(1.011)]. 

One way of interpreting the formula stem:[P_{t+1} = P_t(1.011)] is to see that _the new value of stem:[P] is the old value of stem:[P] times 1.011_. We have seen this pattern before in code. It is just an assignment statement:

[source,pthon]
----
P = P * 1.011
----

We can just keep iterating this statement after we give it an initial population.

[source,python]
----
P = 7.5e9      # initial population
P = P * 1.011  # population after year 1
P = P * 1.011  # population after year 2
P = P * 1.011  # population after year 3
# and so on
----

of course if we want to compute the population _P_ after _n_ years we should use a loop.

[source,python]
----
P = 7.5e9    # initial population 7.5 billion
i = 0        # counter
r = .011     # growth rate 1.1%
n = int(input("Enter a number of years: "))

while i < n:
    P = P * (1 + r)
    i = i + 1

print("Final population: ", int(P))
---- 

Assume we have current population of roughly 7.5 billion.footnote:[https://www.census.gov] If we look at plots over a 10 year (top left), 100 year (top right), 1000 year (bottom left), and 5000 year (bottom right) time horizon then the year plot looks nearly _linear_. But as we progress up to 5000 years we see that this seemingly linear growth is a mirage and we have a curve that is definitely exponential.

[cols="2"]
|===
| image:pop-10-year.png[width=300,height=300]
| image:pop-100-year.png[width=300,height=300]

| image:pop-1000-year.png[width=300,height=300]
| image:pop-5000-year.png[width=300,height=300]
|===

NOTE: _Linear growth_ folows the equation of a line, stem:[y=mx+b] where _m_ is the slope and _b_ is the _y_-intercept.

NOTE: The mathematically inclined will notice that if we just keep iterating the statement stem:[P = P(1+r)] we can use a little algebra and keep substituting stem:[P(1+r)] for stem:[P].  Substituing once we get stem:[P = P(1+r)(1+r) = P(1+r)^2]. If we substitute a third time we get stem:[P = P(1+r)(1+r)(1+r) = P(1+r)^3]. After stem:[n+1] substitutions we get stem:[P_{n+1} = P(1+r)^n]. And the exponential is obvious. 

.Check Yourself +++<span style='color:red;margin-right:1.25em; display:inline-block;'>&nbsp;&nbsp;&nbsp;</span>+++
When using a loop like this we can easily ask alternative questions such as _how many years will it take to reach a population of 10 billion_? This is just a simple matter of rephrasing the loop condition.

[.result]
====
[source,python]
----
p = 7.5e9    # initial population 7.5 billion
i = 0        # counter
r = .011     # growth rate 1.1%

while p < 10e9:
    p = p * (1 + r)
    i = i + 1

print(i, "years to 10 billion") 
----
====

.Check Yourself 
The population growth rate is not constant. It fluxuates and has increased and decreased over the centuries. Currently it is decreasing at a rate of about _.025%_ per year (.00025). Can we modify our program to incorporate a decreasing growth rate? The beauty of programming is that incorporating changes like this is very easy compared to trying to figure out the mathematics.  Below is a graph over a 50 year period beginning with our current population. After 50 years the population is approximatel stem:[9.5 \times 10^9].

image:pop-decreasing-growth.png[align"center"]

If the growth rate decreases long enough it will eventually become negative. Correspondingly the population will start shrinking. 

.Answer  +++<span style='color:red;margin-right:1.25em; display:inline-block;'>&nbsp;&nbsp;&nbsp;</span>+++
+++<span style='color:red;margin-right:1.25em; display:inline-block;'>&nbsp;&nbsp;&nbsp;</span>+++

[.result]
====
[source,python]
----
p = 7.5e9    # initial population 7.5 billion
i = 0        # counter
r = .011     # growth rate 1.1%
n = int(input("Enter a number of years: "))

while i < n:
    p = p * (1 + r)
    i = i + 1
    r = r - .00025 <1>

print("Final population: ", int(p))
----
<1> This is the only line that has changed from the original solution. The rate decreases by _.025%_ every year.
====

=== Checksums; detecting network communication errors

A _checksum_ is an integer derived from a larger integer and is used to detect errors in network communication.  There are many different checksum techniques but one of the most common is to add up the digits in an integer number modulo ten, and then append that number to the original integer. Recall that in a computer, everything is represented as bits (music, images, web pages, Word documents, etc. Sequences of bits are just integers. Rather than work in the language of bits, 
0s and 1s, we'll use the more familiar base-ten digits 0-9.

If a network was transmitting the number stem:[51623] we would compute the checksum by computing stem:[(5+1+6+2+3) % 10 = 7] and we would then transmit the number stem:[516237]. What would happen if there was an error in the transmission and the number transmitted was stem:[596237]. We take off the checksum digit which is 7, and compute 
the checksum of stem:[59623] which is stem:[(5+9+6+2+3) % 10 = 5] and we see that stem:[7 \neq 5] so there must have been an error in the transmission.

Why does this work? First this only works if there is a single error in a digit. It is easy to construct a case where if there were multiple errors this would not work. For example, if there were two errors in the original communication such as stem:[526137] the checksum is still 7. If there is only single error it makes sense that a change in any single digit would change the final checksum mod 10.

How do we write program to compute a checksum? If we have an integer such as stem:[51623] we can peel of the last digit using % 10, stem:[51623 % 10 = 3]. Then we need to the remaining digits stem:[5162]. We can get that using _integer division_ by 10, stem:[51623 // 10 = 3]. We just keep repeating this process adding up the remainder until the number has been reduced to 0.

We can put this in a function that takes an integer to compute the checksum of and return the checksum.

[source,python]
----
def checksum(n):               <1>
    sum = 0                    <2>
                             
    while n > 0:               <3>
        sum = sum + (n % 10)   <4>
        n = n // 10            <5>
    return sum % 10            <6>
----

.Review

. Does the `checksum` function use any local variables?
. `n` is a ________________ 
. Line 1 is the  ________________ 
. What is the value of `checksum(91242)`

How can we append the checksum of an integer on the end (the _least significant digit_)? FOr example if the checkum of the integer stem:[51326] is stem:[7] how do we build th new integer stem:[513267]?

[source,python]
----
 check = checksum(x) <1>
 data = x * 10 + check <2>
----
<1> Compute the checksum of `x`, the integer we want to transmit
<2> Multiply `x` by 10 shifting it left, and then add in the checksum digit `check`.

=== Exercises

.Exercise 1

The Fibonacci Sequence

.Exercise 2

Sum of squares

.Exercise 3

_TBD: Turn some of the previous examples in to functions._

.Exercise 4

Write a function `num_digits` that will return the number of digits in an integer. For example,
if we were to call `num_digits(5132981)` it would return 7 because there are 7 digits in 5132981. Hint: similar to the `checksum` algorithm.

.Exercise 5

Compute the average of numbers entered by the user.

=== Terminology 

.Terminology
[cols="2"]
|===

a| 
* particle
* loop condition
* convention
* counting loop
* brute force attack
* linear growth

a|
* loop body
* sprite
* accumulating loop
* infinite loop
* exponential growth
* checksum

|===

== Conditionals

Lets say we wanted to simulate tossing a coin and print `Heads` or `Tails`.

The `random` module contains many functions for generating random numbers. The function `random.random()` returns a `uniform` floating-point number between 0 and 1.

NOTE: A random number generator is _uniform_ if all outcomes are equally likely.

[source,python]
----
import random
print(random.random())
----

 0.2840077963246783

The function `random.randrange(n)` returns a _uniform_ random integer between 0 and `n-1` inclusive. 

[source,python]
----
import random
print(random.randrange(6))
----

 5

The if-statement executes one of two possible blocks of statements depending on a condition.

[source,python,subs="quotes"]
----
if (*_condition_*):
    true_stmts
else:
    false_stmts
----

If the condition is true then the block of statement labelled `true_stmts` will be executed, otherwise the block of statements labelled `false_stmts` will be executed. The else part is optional.  `if` and `else` are new _keywords_. They cannot be used as variable or function names. Notice also that the statements under the `if` of `else` are indented just like a functin body, or the body of a while loop.

Back to simulating a coin toss. Here is one way using `random.random()`

[source,python]
----
import random
x = random.random()

if x < 0.5:
    print("Heads") <1>
else:
    print("Tails")
----
<1> Assigning heads to be less than .5 is, of course, arbitrary.

Here is another way using `random.randrange()`

[source,python]
----
import random
x = random.randrange(2)

if x == 0:
    print("Heads") <1>
else:
    print("Tails")
----
<1> Similar to the above, assigning heads to be 0 is arbitrary.

.Check Yourself +++<span style='color:red;margin-right:1.25em; display:inline-block;'>&nbsp;&nbsp;&nbsp;</span>+++
Write a program that reads an integer from the keyboard and prints `even`, if the number was even, or `odd` if the number was odd. A number is even if it is divisible by two. That is, the raminder after dividing by two is zero.

[.result]
====
[source,python]
----
n = int(input("Enter an integer: "))

if n % 2 == 0:
    print(n, "is even")
else:
    print(n, "is odd")
----
====

=== if-elif-else

Loops and conditionals can be combined in complex ways. Lets take an example of tossing a single die.footnote:[_die_ is the singular of the plural _dice_, one die, pair of dice.]. We will print `one` if we rolled a one, `two` if we rolled a two, etc. One way to write this:

[source,python]
----
import random

d = random.randrange(6) + 1
if d == 1:
    print("one")
else:
    if d == 2:
        print("two")
    else:
        if d == 3:
            print("three")
        else:
            if d == 4:
                print("four")
            else:
                if d == 5:
                    print("five")
                else:
                    print("six")
----

This is pretty confusing and not very readable. Most programming languages have an alternative form of the if-statement that we sometimes call _if else if_. Here is Python's version:

[source,python,subs="quotes"]
----
if (*_condition1_*):
    stmts1
elif (*_condition2_*):
    stmts2
elif (*_condition3_*):
    stmts3

	...
	
else:             
    stmts_else
----

The final `else` clause is optional. Note the new keyword `elif`.  `condition1` is checked first and if it is true then `stmts` is executed, and the remainder of the if-elif-statement is skipped. If `condition1` is false we check `condition2` and so on. 

Now we can write our die toss program as:

[source,python]
----
d = random.randrange(6) + 1
if d == 1:                 
    print("one")
elif d == 2:                  
    print("two")
elif d == 3:
    print("three")
elif d == 4:
    print("four")
elif d == 5:
    print("five")
else:
    print("six")
----

=== Logical Operators

Up until now our conditions in either the while loop or the if-statment have been relative simple. Python, as do all other programming languages, allow you to state more complicated conditions such as, _if the temperature greater than 50 and less than 100_. We have new Python keywords `and`, `or`, `not`.

==== Logical `and` 

Lets say we rolled a pair of dice and wanted to check if we rolled two ones (snake eyes). Our first attempt, which is not incorrect, might be:

[source,python]
----
d1 = random.randrange(6) + 1
d2 = random.randrange(6) + 1

if d1 == 1:
    if d2 == 1:
        print("snake eyes!")
----

This works just fine, albeit a bit clunky. More concise would be to use the logical operator `and`.

[source,python]
----
d1 = random.randrange(6) + 1
d2 = random.randrange(6) + 1

if d1 == 1 and d2 == 1: <1>
    print("snake eyes!")
----
<1> `and` is a python keyword.


The logical operator `and` combines a logical value on the left and the right, _X_ `and` _Y_. The entire logical expression is true if both _X_ and _Y_ are true.  We often state this interms of a _truth table_. 

`False` and `True` are Python keywords.

[width="50%", options="header"]
.Logical `and`
|===
| X | Y | X `and` Y

|`False` | `False` | `False`
|`False` | `True` | `False`
|`True` | `False` | `False`
|`True` | `True` | `False`
|=== 

NOTE: A _truth table_ enumerates all possible outcomes of a logical operator for all possible inputs.

.Check Yourself +++<span style='color:red;margin-right:1.25em; display:inline-block;'>&nbsp;&nbsp;&nbsp;</span>+++
Write an if-statement that checks whether an integer `n` is between 0 and 100 inclusive. If it is then set a variable `x` to `0`. Write it two ways, one using a nested if-statement, and the second using the logical `and` operator.

[.result]
====

.Version 1
[source,python]
----
if n >= 0:
    if n <= 100:
        x = 0
----

.Version 2
[source,python]
----
if n >= 0 and n <= 100:
    x = 0
----

These are not complete programs as we haven't assigned a value to `n` yet. We will often call these _code fragments_.
====

NOTE: A _code fragment_ is an incomplete segment of pythoncode. It is not meant to be a complete program.


==== Logical `or` 

Returning to our dice roll, lets check to see if at least one of the dice is a one. Again, your first instinct might be to write this using if-statements alone, which is possible.

[source,python]
----
d1 = random.randrange(6) + 1
d2 = random.randrange(6) + 1

if d1 == 1:
    print("one")
elif d2 == 1:
    print("one")
----

But a more concise way would be to use the logical `or` operator.

[source,python]
----
d1 = random.randrange(6) + 1
d2 = random.randrange(6) + 1

if d1 == 1 or d2 == 1: <1>
    print("one")
----
<1> `or` is a python keyword.

The logical operator `or` combines a logical value on the left and the right, _X_ `or` _Y_. The entire logical expression is true if either one of _X_ or _Y_ are true.  The truth table for logical `or` is: 

[width="50%", options="header"]
.Logical `or`
|===
| X | Y | X `or` Y

|`False` | `False` | `False`
|`False` | `True` | `True`
|`True` | `False` | `True`
|`True` | `True` | `True`
|===

When `and` and `or` are both used in an expression `and` has a higher precedence (much like `*` does over `+`).

.Check Yourself +++<span style='color:red;margin-right:1.25em; display:inline-block;'>&nbsp;&nbsp;&nbsp;</span>+++
Write a code fragment that will determine whether a user rolled exactly one 1. 
Assume variable `d1` and `d2` have values.

[.result]
====
There several ways to write this. Here is one way.

[source,python]
----
if (d1 == 1 or d2 == 1) and d1 != d2: <1>
    print("exactly one, 1")
----

The parentheses around the `or` are necessary.  Another solution is:

[source,python]
----
if (d1 == 1 or d2 == 1) and (d1 != 1 or d2 != 1): <1>
    print("exactly one, 1")
----
<1> Note the parentheses, they are necessary.
====

==== Logical `not`

The remaining logical operator is `not`, the logical negation of `True` and `False`. The truth table is simply

[width="25%", options="header"]
.Logical `not`
|===
| X | `not` X

|`False` | `True`
|`True`  | `False`
|===


=== Exercises

. logical operator exercises
. larger smaller of two numbers
. larger smaller of three numbers
. median of three numbers

=== Terminology 

.Terminology
[cols="2"]
|===

a| 
* uniform random number
* code fragment
* truth table

a|
* `and`
* `or`
* `not`

|===

== A Random Walk 

The real power in programming comes from how we can combine loops, conditional statements, and functions in creative ways to solve or explore a problem.  We will continue our investigations in 
programming by exploring the nature of _randomness_.footnote:[Randomness plays an important role in many areas of computer science, including cryptography, networking, and simulation and modeling.]

NOTE: A computer program is _deterministic_ if it produces the same exact results every time it executes.

NOTE: "A random process models the progression of a system over time, where the evolution is random rather than deterministic."footnote:[https://reference.wolfram.com/language/guide/RandomProcesses.html]

Lets simulate tossing a coin _n_ times counting the number of ooccurrences of a head or a tail. We will have _n_ be input by the user. Lets start by tossing a coin once and checking if it is heads or tails. We will use a variable `heads` to keep track of the number times heads appeared and a variable `tails` for the number of times tails appeared.

[source,python]
----
toss = random.randrange(2)

if toss == 0:
    heads = heads + 1 <1>
else:
    tails = tails + 1 <2>
----
<1> This is actually a syntax error because `heads` is not yet defined.
<2> Same comment. `tails` is not yet defined.

This is the loop body, all we need to do now is to get _n_ from the user, initialize the `heads` and tails` variables, and use a counting loop to toss the die _n_ times.

TIP: Don't try and write the program all at once. Break into parts.

[source,python]
----
import random

n = int(input("Enter number of times to toss coin: "))

i = 0       # loop counter
heads = 0   # number of heads tossed
tails = 0   # number of tails tossed

while i < n:
    toss = random.randrange(2) <1>

    if toss == 0:
        heads = heads + 1
    else:
        tails = tails + 1
    i = i + 1

print("Heads: ", heads)
print("Tails: ", tails)
----
<1> A common mistake is to put this statement before the loop.

One of the benefits of writing a program like this, a _simulation_, is that we can simulate tossing a coing thousands, millions, or even billions of times. Something that is not possible if we were to try and do this by hand with a real coin.

TIP: If you think you need a loop try and figure out what the process is that needs to be repeated. Then, put that in the loop as the loop body.

NOTE: A _computer simulation_ is a computer program that represents a simulation (or model) of some realy world process. 

As you might expect when you run this program that number of times heads and tails are rolled is roughly equal. But this only prints the final result. What is going on during all of tossing?

.Check Yourself
Modify the coint toss program to count the number of times we toss ten heads in a row. if we ever toss ten heads in a row. How big do you have to make _n_ in order to get ten heads in a row?

[.result]
====
This is just one possible solution.

[source,python]
----
import random

n = int(input("Enter number of times to toss coin: "))

i = 0
heads = 0
tails = 0
in_a_row = 0         <1>
in_a_row_count = 0   <2>

while i < n:
    toss = random.randrange(2)

    if toss == 0:
        heads = heads + 1
        in_a_row = in_a_row + 1 <3>
    else:
        tails = tails + 1
        in_a_row = 0            <4>

    if in_a_row == 10:          <5>
        in_a_row_count = in_a_row_count + 1

    i = i + 1

print("Heads: ", heads)
print("Tails: ", tails)
print("Number of ten in a row: ", in_a_row_count)
----
<1> A counter for keeping track of number of heads in a row.
<2> Keep track of the number of times we roll heads ten in a row.
<3> When we roll heads, increment the counter.
<4> If we roll tails, reset the counter.
<5> Check to see if we hit ten in a row.

====

=== The Gambler's Ruin

Lets modify our coin toss program and see if we can learn something about randomness. A gambler starts out with a certain number of chips, say one thousand. The gambler is playing the coin toss game, if they guess correctly they win a chip, and lose one of they are wrong. So they have a 50-50 chance each time (better odds than a real real casino.)

How long will the gambler play? Well, a recreational gambler might play until they lose everything or hit some goal, such as double your chips. Lets modify the coin toss program and turn it in to the coin toss gambling game. We could ask the user every time if they want to choose heads or tails, but this may take a long time, and we will want to see what happens over long stretches. Since it doesn't matter what the gambler guesses, because it is always 50-50, we can have the program just always chose heads (or tails) for the guess.

[source,python]
----
import random
chips = 1000
while chips > 0 and chips < 2000:
    toss = random.randrange(2)

    if toss == 0:  
        chips = chips + 1
    else:
        chips = chips - 1

print(chips) <1>
----
<1> Will print either 0 or 2000.

As you might expect about half the time the player loses everything and half the time they double their money. But a gambler with a problem typically can't quit, even when they are ahead. What might the program look like now?  

[source,python]
----
import random
chips = 1000
while chips > 0:  <1>
    toss = random.randrange(2)

    if toss == 0:  
        chips = chips + 1
    else:
        chips = chips - 1
print(chips) <2>
----
<1> The only change is to remove the condition that the loop terminate when `chips` reaches 2000.
<2> What will always get printed?

We don't even need to run the program to see what will happen here. This is the _Gambler's Ruin_. A gambler who gambles long enough will always lose everything!

==== A One Dimensional Random Walk

Lets visualize this random process, plotting the number of chips the gambler has over time. It will be instructive to let the number of chips go negative (similar to borrowing chips from the casino). Assuming we have a pygame window of width _w_ and height _h_, if we let the center _y_ coordinate of the window represent 0 chips then `0 - chips` will be the _y_ coordinate of where we need to draw a pixel. If we keep a counter `i` for each toss of the coin then `i` will represent the `x` coordinate. 

The pygame command 

[source,python]
----
win.set_at( (x,y), RGB)
----

draws a single pixel at coordinate `(x,y)` with the  color `RGB` (which should be an RGB triple).

[source,python]
----
import random,pygame,color
pygame.init()
win = pygame.display.set_mode((600,600))
win.fill(color.white)

i = 0
chips = 0
scale = 100                       <1>

while i < win.get_width()*scale:  <2>
    n = random.randrange(2)

    if n % 2 == 0:
        chips = chips + 1
    else:
        chips = chips - 1

    win.set_at((i//scale, h//2 - chips), color.black) <3>

    pygame.draw.line(win, color.red, (0,h//2), (h-1,h//2)) <4>
    pygame.display.update()
    i = i + 1
----
<1> Rather than drawing only one point for each x-coordinate, we can fit more points if we plot multiple points at each coordinate. The `scale` variable is used for this.
<2> Only draw until we fill the screen
<3> Plot our current chip count. Notice the use of the `scale` variable to plot multiple points at each x-coordinate.
<4> Keep redrawing a red line in the middle to represent zero chips. 

The random walk on the left plots 10 points per x-coordinate `scale = 10`. The plot on the right
plots 100 points per pixel `scale = 100`. 

[cols="2"]
|===
| image:rand_walk1.png[width=300,height=300]
| image:rand_walk2.png[width=300,height=300]

|===

Even though we have a 50-50 chance of increasing our decreasing our chip count on every roll notice that we still go on long winning or long losing streaks.

.Check Yourself +++<span style='color:red;margin-right:1.25em; display:inline-block;'>&nbsp;&nbsp;&nbsp;</span>+++
Modify the random walk above so that whenever we have a positive chip count we plot a green pixel. FOr a negative chip count plot a red pixel.

[.result]
====
[source,python]
----
TBD
----
====

.Check Yourself +++<span style='color:red;margin-right:1.25em; display:inline-block;'>&nbsp;&nbsp;&nbsp;</span>+++
Modify the random walk so that whenever we hit a new high we mark the location by printing a small red circle (slightly bigger than a single pixel).  When we hit a new low plot a red circle at the location.

[.result]
====
[source,python]
----
TBD
----
====

The Gambler's Ruin is an example of a _random walk_. Random walks are useful for builing models in many disciplines including economics.footnote:[One of the best know books on investing is _A Random Walk Down Wall Street_ by Burton Malkiel.] and physics.  In economics random walks are often used to model fluxuations in random processes such as the stock market. In physics, a random walk can model random motions such as _Brownian Motion_. 

Random walks have a sophisticated and complex mathematical theory. However, notice how straighforward it is to do some simple programming experiments and learn something about random processes without having to understanding the mathematics.

The Gambler's Ruin is an example of a _one dimensional reandom walk. One dimensional becuase there is only one random variable.

=== Brownian Motion (or the _Drunkard's Walk_)

Brownian Motion is the random movement of particles suspended in a liquid or gas.  Botanist Robert Brown discovered this while noticing the random movement of pollen particles in a water. In this particular case the particle can move randomly in either the x or y direction.  In terms of a graphic display particle st coordinate _(x,y)_ has 
eight possible neighboring locations that it can move to, forgetting, for the time being about a particle that is on an edge. 

image::pixel_neighbors.png[width=214,height=200,align="center"]

In this case we will have two random variables, one in the x direction and one in the y direction.  Assuming that `x` and `y` is the coordinate of the particle how can we make it move randomly to one of the eight neighbors? We can simulate tossing an eight sided die and update `x` ad `y` accordingly.

[source,python]
----
dir = random.randrange(8)
if dir == 0:     # top middle 
	y = y - 1
elif dir == 1:   # top right
	x = x + 1
	y = y - 1
elif dir == 2:   # right middle
	x = x + 1
elif dir == 3:   # lower right
	x = x + 1
	y = y + 1
elif dir == 4:   # botton middle
	y = y + 1
elif dir == 5:   # bottom left
	y = y + 1
	x = x - 1
elif dir == 6:   # left middle
	x = x - 1
else:            # top left
	x = x - 1
	y = y - 1
----

This is essentially the process we need to repeat overand over (when do we quit?, hold that thought).  But first lets think about this code segment. Putting this in the loop body will make our loop a little unwieldy. Instead lets think of it in terms of a function `move` that takes a particle's current `x` and `y` cordinate and returns its new `x` and `y`. Pictorially, 

image::2D_move.png[width=362,height=130,align="center"]

[source,python]
----
def move(x,y):
    # insert code from above
    return (x,y)
----

We can start a particle in the middle of the window (or at any random location for that matter) but what should we do when the particle is at an edge? We have several options, don't let the particle 

=== A Fractional Dimension Random Walk (or Fractal)

Sometimes called the _chaos game_


=== The Monty Hall Problem


=== Exercises

. prime
. euler problem
. count 7s
. modifications to each random walk

=== Terminology 

.Terminology
[cols="2"]
|===

a| 
* random process
* determinstic

a|
* computer simulation
* random walk

|===


== Animation: Particles and Collision


=== Pong

== Image Processing

== String and File Processing

=== DNA Sequence Analysis

=== Cryptography

=== Web Access

== Lists

[appendix]

== Installing Python, Pygame, and Pycharm

=== Installing Python

=== Installing Pygame

=== Installing Pycharm

=== Python functions

* random.randrange(n)
* random.random()
* math.sqrt(n)

=== Pygame Functions

* pygame.display.set_mode((w,h))


